//-------------------------------------------------------------
// ðŸ“Œ Native Database Types in Prisma (`@db`)
//-------------------------------------------------------------
//
// - Prisma provides generic scalar types (String, Int, Boolean, etc).
// - By default, Prisma maps them to the "most common" DB column type.
// - Using `@db.<Type>` overrides the column type to a **native DB type**.
//
// âœ… Pros of @db:
//   - Exact control over DB schema (VARCHAR(255), DECIMAL(8,2), etc).
//   - Compatibility with legacy schemas.
//   - Helps fine-tune storage + indexing.
//
// ðŸš¨ Cons of @db:
//   - Locks you into a specific DB provider.
//   - Harder to migrate between databases.
//   - Only use when necessary (precision, legacy compatibility).
//
//-------------------------------------------------------------
// PROVIDER: POSTGRESQL
//-------------------------------------------------------------

// ðŸ”¹ STRING FIELDS
model PostgresString_Default {
  id    Int    @id @default(autoincrement())
  email String // Default â†’ TEXT
}

model PostgresString_DB {
  id    Int    @id @default(autoincrement())
  email String @db.VarChar(5) // Explicit VARCHAR(255)
}

// ðŸ”¹ BOOLEAN
model PostgresBoolean_Default {
  id      Int     @id @default(autoincrement())
  isActive Boolean // Default â†’ BOOLEAN
}

model PostgresBoolean_DB {
  id      Int     @id @default(autoincrement())
  isActive Boolean @db.Boolean // Explicit BOOLEAN
}

// ðŸ”¹ INT (32-bit)
model PostgresInt_Default {
  id   Int @id @default(autoincrement()) 
  // Default â†’ INTEGER
  @@ignore
}


// ðŸ”¹ BIGINT (64-bit)
model PostgresBigInt_Default {
  id   BigInt @id @default(autoincrement()) 
  // Default â†’ BIGINT
  @@ignore
}

// ðŸ”¹ FLOAT / DOUBLE PRECISION
model PostgresFloat_Default {
  id    Int   @id @default(autoincrement())
  score Float // Default â†’ DOUBLE PRECISION
}

model PostgresFloat_DB {
  id    Int   @id @default(autoincrement())
  score Float @db.DoublePrecision // Explicit DOUBLE PRECISION
}

// ðŸ”¹ DECIMAL
model PostgresDecimal_Default {
  id    Int     @id @default(autoincrement())
  price Decimal // Default â†’ NUMERIC
}

model PostgresDecimal_DB {
  id    Int     @id @default(autoincrement())
  price Decimal @db.Decimal(10,2) // Explicit NUMERIC(10,2)
}

// ðŸ”¹ BYTES (BINARY DATA)
model PostgresBytes_Default {
  id      Int   @id @default(autoincrement())
  content Bytes // Default â†’ BYTEA
  @@ignore
}

// ðŸ”¹ DATE & TIME
model PostgresDate_Default {
  id        Int      @id @default(autoincrement())
  createdAt DateTime // Default â†’ TIMESTAMP(3)
}

model PostgresDate_DB {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @db.Timestamptz(6) // Explicit TIMESTAMPTZ(6)
}

// ðŸ”¹ UUID
model PostgresUuid_Default {
  id   String @id @default(uuid()) // Default â†’ TEXT
}

model PostgresUuid_DB {
  id   String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  // Explicit UUID type
}

// ðŸ”¹ JSON
model PostgresJson_Default {
  id   Int   @id @default(autoincrement())
  meta Json  // Default â†’ JSONB
}

model PostgresJson_DB {
  id   Int   @id @default(autoincrement())
  meta Json  @db.Json // Explicit JSON
}

//-------------------------------------------------------------
// PROVIDER: MYSQL
//-------------------------------------------------------------

// ðŸ”¹ STRING FIELDS
model MysqlString_Default {
  id    Int    @id @default(autoincrement())
  email String // Default â†’ VARCHAR(191)
}

model MysqlString_DB {
  id    Int    @id @default(autoincrement())
  email String @db.VarChar(255) // Explicit VARCHAR(255)
}

// ðŸ”¹ NUMERIC FIELDS
model MysqlNumber_Default {
  id    Int     @id @default(autoincrement())
  price Decimal // Default â†’ DECIMAL(65,30)
}

model MysqlNumber_DB {
  id    Int     @id @default(autoincrement())
  price Decimal @db.Decimal(10,2) // Explicit DECIMAL(10,2)
}

// ðŸ”¹ DATE & TIME
model MysqlDate_Default {
  id        Int      @id @default(autoincrement())
  createdAt DateTime // Default â†’ DATETIME(3)
}

model MysqlDate_DB {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @db.Timestamp(6) // Explicit TIMESTAMP(6)
}

//-------------------------------------------------------------
// PROVIDER: SQLITE
//-------------------------------------------------------------

// ðŸ”¹ STRING
model SqliteString_Default {
  id    Int    @id @default(autoincrement())
  email String // Default â†’ TEXT
}

model SqliteString_DB {
  id    Int    @id @default(autoincrement())
  email String @db.Text // Explicit TEXT
}

// ðŸ”¹ NUMERIC
model SqliteNumber_Default {
  id    Int     @id @default(autoincrement())
  price Decimal // Default â†’ NUMERIC
}

model SqliteNumber_DB {
  id    Int     @id @default(autoincrement())
  price Decimal @db.Decimal(8,2) // Explicit DECIMAL(8,2)
}

//-------------------------------------------------------------
// PROVIDER: SQL SERVER
//-------------------------------------------------------------

// ðŸ”¹ STRING
model SqlServerString_Default {
  id    Int    @id @default(autoincrement())
  email String // Default â†’ NVARCHAR(1000)
}

model SqlServerString_DB {
  id    Int    @id @default(autoincrement())
  email String @db.VarChar(255) // Explicit VARCHAR(255)
}

// ðŸ”¹ NUMERIC
model SqlServerNumber_Default {
  id    Int     @id @default(autoincrement())
  price Decimal // Default â†’ DECIMAL(18,0)
}

model SqlServerNumber_DB {
  id    Int     @id @default(autoincrement())
  price Decimal @db.Decimal(10,2) // Explicit DECIMAL(10,2)
}

//-------------------------------------------------------------
// âœ… Gotchas & Tips
//-------------------------------------------------------------
// 1. Indexing:
//    - MySQL: VARCHAR index length is limited (191 chars for utf8mb4).
//    - Postgres: TEXT canâ€™t be indexed efficiently â†’ prefer VARCHAR.
//
// 2. Precision:
//    - MySQL Decimal default (65,30) is huge â†’ set with @db.Decimal(10,2).
//
// 3. Migration Impact:
//    - Removing @db may cause Prisma to change column type â†’ risky.
//
// 4. Best Practice:
//    - Use Prisma defaults UNLESS you specifically need @db for:
//      - Legacy schema compatibility.
//      - Precision control.
//      - Performance reasons.
//
//-------------------------------------------------------------
